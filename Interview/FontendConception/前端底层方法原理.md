## 前端底层方法原理

#### 发布-订阅模式/观察者模式

**观察者模式**：一群观察者（Observers）观察监听某个被观察对象（Subject），当有关状态发生变化时，Subject会通知这一系列Observers触发更新。

```javascript
function Subject(){
	this.observers = [];
}
Subjects.prototype = {
    //添加观察者
    add: function(observer){
        this.observers.push(observer)
    }
    //移除观察者
    remove: function(observer){
        let observers = this.observers;
        let len = observers.length;
        for (let i = 0; i<len; i++){
            if(observers[i] === observer){
                observers.splice(i,1);
            }
        }
    }
	notify: function(){
        let observers = this.observers;
        let len = observers.length;
        for(let i=0;i<len;i++){
            observers[i].update();
        }
    }
}

//观察者
function Observer(name){
    this.name = name;
}
Observer.prototype = {
    update: function(){
        conosole.log('被通知了---我是观察者', this.name);
    }
}

// 使用示例：
var subject = new Subject();
var john = new Observer('john');
var alice = new Observer('alice');
subject.add(john);
subject.add(alice);
subject.notify();  
// 最终输出结果：
// 被通知了---我是观察者： john
// 被通知了---我是观察者： alice
```

**发布订阅模式**：一群订阅者（Subscriber）通过消息调度中心来实现基于某个主题去订阅发布者（Publisher）,当有关状态发生变化时，Publisher会基于某个主题去通知该主题下对应的订阅者（Subscriber）触发更新。相比于上面的观察者模式而言，能够实现发布者与订阅者之间的解耦，而且能基于不同主题来添加订阅者，从而实现更为颗粒度的控制。

```javascript
function PubSub(){
    this.list = {};   // 主题列表
}
PubSub.prototype = {
    // 添加订阅
    subscribe: function(key, fn){
        if(!this.list[key]) {
            this.list[key] = [];
        }
        this.list[key].push(fn);
    },
    // 取消订阅
    unSubscribe: function(key){
        delete this.list[key];
    },
    // 发布通知
    publish: function(key, para){
        if(!this.list[key]){
            alert('没有该主题---');
            return;
        }
        let arr = this.list[key];
        for(var j=0; j<arr.length; j++){
            arr[j](para);
        }
    }
}
var Pub = new PubSub();
// 为不同主题（如主题sing或者dance）添加订阅者
Pub.subscribe('sing', function(songName){
    console.log('sing 订阅者01 歌名为 ', songName)
})
Pub.subscribe('sing', function(songName){
    console.log('sing 订阅者No2 歌名为 ', songName)
})
Pub.subscribe('dance', function(para){
    console.log('dance 订阅者 歌名为 ', para)
})
// 根据不同主题（如主题sing或dance），发布不同消息
Pub.publish('sing', 'Heal the word');
Pub.publish('dance', '华尔兹舞曲');
// 最后输出结果：
// sing 订阅者01 歌名为  Heal the word
// sing 订阅者No2 歌名为  Heal the word
// dance 订阅者 歌名为  华尔兹舞曲
```

#### 事件代理/事件委托

 用于解决过多 绑定类似li事件 

 利用事件冒泡和 `e.target ` 解决多次绑定只需要在 `ul` 上设置点击事件

`e.target.nodeName === ‘li’;` 

才会处理事件



#### Promise 原理和实现

1. Promise基本结构

```javascript
new Promise((resolve, reject) => {
  setTimeout(() => {
    resolve('FULFILLED')
  }, 1000)
})
```

 状态只能由 `Pending` 变为 `Fulfilled` 或由 `Pending` 变为 `Rejected` ，且状态改变之后不会在发生变化，会一直保持这个状态。

1. Promise对象初始状态值为`pending`
2. 立即执行excutor,在excutor中可以通过resolve,reject方法改变promise状态，分别改为filfiled（成功）和rejected（失败）
3. 状态一旦改变状态就凝固了，无法再变
4. then方法中的回调函数会在状态改变后执行，成功调成功回调，失败调用失败回调
5. resolve中的值会传递到成功的回调函数参数中 （失败类似）



#### 跨域原理与实现

跨域是浏览器的一个特性，就是**浏览器从一个“域”向另一个“域”的服务器发出请求**，来访问另一个“域”上的资源。但是，由于请求的文件**可能会存在恶意攻击**，浏览器并不允许直接访问另一个“域”上的资源，只能访问同一个“域”上的资源，这个就是“同源策略”。而所谓的“同源”，指的是“**协议、域名、端口号”一致**

**JSONP**

Json with Padding 原理：<script>标签的跨域是不受同源策略限制的

我们向后端请求一个js文件，在这个js文件当中，返回一个函数的执行，而我们想要得到的数据，是这个函数的参数。比如，创建一个名叫jsonpData.js'的文件：

```js
showData({
  name: "Crimson fire",
  culture: "Yaaxil"
})
```

在前端发送请求的时候，服务器中，我们把这个js文件发送出去：

```js
if (req.url === '/jsonpData.js') {
    fs.readFile('./jsonpData.js', function (err, file) {
      res.setHeader('Content-Type', 'text/js');
      res.writeHead('200', "OK");
      res.end(file);
  });    
}
```

而在前端，我们创建请求对jsonpData.js文件的请求（添加一个script标签），之后，关键的地方来了：我们要在前端定义showData这个函数，来处理传送进来的数据！比如：

```js
const s = document.createElement("script");
s.src = "http://localhost:8082/jsonpData.js";
document.body.appendChild(s);

function showData(myObj) {
  document.getElementById("name").innerHTML = myObj.name;
  document.getElementById("culture").innerHTML = myObj.culture;
}
```

这样当jsonpData.js发送到前端的时候，里面的showData函数会按照前端的定义执行，就会把参数的值替换到id为name和culture的元素上。

不过JSONP只能处理GET请求，只是权宜之计。



**CORS(后端配置)**

CORS是Cross-Origin Resource Sharing的缩写。

CORS请求分两种：简单请求和预检请求。这样分类的原因是因为，有些请求会对服务器产生副作用（比如PUT或者DELETE请求，会更改现有的数据），因为浏览器需要通过OPTIONS方法预检，查看自己是否可以跨域。

1. **简单请求：**

   某些请求不会触发 [CORS 预检请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CORS#preflighted_requests)，对于简单请求，浏览器向服务器发起的request header中，会有一个origin字段，表示当前的“源”，服务器返回的response header中，会有一个Access-Control-Allow-Origin字段，里面写明允许那些“源”，浏览器发现两者一致，或者服务器允许所有的“源”，那么跨域成功！

   使用下列方法之一：

   [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)

   [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)

   [`POST`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/POST)

2. **预检请求：**

   而对于预检请求，则浏览器会向服务器发起一个OPTIONS请求，检查自己是否允许自己的实际请求。

   下面是一个NodeJS服务器配置CORS的例子，例子中允许所有的“源”的请求，请求方法是'PUT, GET, POST, DELETE, OPTIONS'：

```js
if (req.url === '/data') {
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Headers', 'X-Requested-With');
    res.setHeader('Access-Control-Allow-Methods', 'PUT, GET, POST, DELETE, OPTIONS');
    res.setHeader('Content-Type', 'text/json');
    res.writeHead('200', 'OK');
    res.end(JSON.stringify(data)); 
  }
```



**反向代理**

跨域只是浏览器向服务器发送请求的时候，浏览器的限制。而服务器和服务器之间是没有跨域的限制的。反向代理是利用代理服务器接收到请求之后，转发给真正的服务器，并把结果返回到浏览器上。

下面这个例子使用vue-cli的http-proxy-middleware来做代理：在使用vue-cli创建的项目的本地运行中，创建vue.config.js文件，里面放入如下内容：

```js
module.exports = {
  devServer: {
    proxy: {
      '^/': {
        target: 'http://localhost:8082/' // api server
      }
    }
  }
}
```

这样，代理服务器就可以把收到的请求转发给`http://localhost:8082/`这个源。不过注意，在vue的代码中，ajax请求url不能直接写[http://localhost:8082/](https://link.zhihu.com/?target=http%3A//localhost%3A8082/)data，而是要写成“/data”的形式，这样这个请求才会被代理服务器收到，而不是直接发送给nodejs服务器。



#### webpack的原理, loader 和 plugin 是干什么的? 

**1. webpack常见配置**

```js
// 入口文件
  entry: {
    app: './src/js/index.js',
  },
  // 输出文件
  output: {
    filename: '[name].bundle.js',
    path: path.resolve(__dirname, 'dist'),
    publicPath: '/'     //确保文件资源能够在 http://localhost:3000 下正确访问
  },
  // 开发者工具 source-map
  devtool: 'inline-source-map',
  // 创建开发者服务器
  devServer: {
    contentBase: './dist',
    hot: true                // 热更新
  },
  plugins: [
    // 删除dist目录
    new CleanWebpackPlugin(['dist']),
    // 重新穿件html文件
    new HtmlWebpackPlugin({
      title: 'Output Management'
    }),
    // 以便更容易查看要修补(patch)的依赖
    new webpack.NamedModulesPlugin(),
    // 热更新模块
    new webpack.HotModuleReplacementPlugin()
  ],
  // 环境
  mode: "development",
  // loader配置
  module: {
    rules: [
      {
        test: /\.css$/,
        use: [
          'style-loader',
          'css-loader'
        ]
      },
      {
        test: /\.(png|svg|jpg|gif)$/,
        use: [
          'file-loader'
        ]
      }
    ]
  }

```

**2. 打包原理**

- 识别入口文件
- 通过逐层识别模块依赖。（Commonjs、amd或者es6的import，webpack都会对其进行分析。来获取代码的依赖）
- webpack做的就是分析代码。转换代码，编译代码，输出代码
- 最终形成打包后的代码



**3.  Loader**

loader是文件加载器，**它就是一个转换器，将A文件进行编译形成B文件，这里操作的是文件，比如将A.scss或A.less转变为B.css，单纯的文件转换过程.** 能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中

- 处理一个文件可以使用多个loader，**loader的执行顺序是和本身的顺序是相反的，即最后一个loader最先执行，第一个loader最后执行。**
- 第一个执行的loader接收源文件内容作为参数，其他loader接收前一个执行的loader的返回值作为参数。最后执行的loader会返回此模块的JavaScript源码

reverse-loader.js

```js
module.exports = function (src) {
  if (src) {
    console.log('--- reverse-loader input:', src)
    src = src.split('').reverse().join('')
    console.log('--- reverse-loader output:', src)
  }
  return src;
}
```

uppercase-loader.js

```js
module.exports = function (src) {
  if (src) {
    console.log('--- uppercase-loader input:', src)
    src = src.charAt(0).toUpperCase() + src.slice(1)
    console.log('--- uppercase-loader output:', src)
  }
  // 这里为什么要这么写？因为直接返回转换后的字符串会报语法错误，
  // 这么写import后转换成可以使用的字符串
  return `module.exports = '${src}'`
}
```

```js
use: [
  './loader/uppercase-loader.js',
  './loader/reverse-loader.js'
]
```



**4.  Plugin**

plugin是一个扩展器，它丰富了wepack本身，**针对是loader结束后**，webpack打包的整个过程，它并不直接操作文件，而是**基于事件机制工作**，会监听webpack打包过程中的某些节点，执行广泛的任务。

##### 一个最简的插件

```js
class MyPlugin {
  // 构造方法
  constructor (options) {
    console.log('MyPlugin constructor:', options)
  }
  // 应用函数
  apply (compiler) {
    // 绑定钩子事件
    compiler.plugin('compilation', compilation => {
      console.log('MyPlugin')
    ))
  }
}

module.exports = MyPlugin
```

webpack配置

```js
const MyPlugin = require('./plugins/MyPlugin')
module.exports = {
  entry: {
    index: './src/js/index.js'
  },
  plugins: [
    ...,
    new MyPlugin({param: 'xxx'})
  ],
  ...
};
```



#### 事件循环原理

**Promise**

- Promise优先于setTimeout宏任务。所以，setTimeout回调会在最后执行
- Promise一旦被定义，就会立即执行
- Promise的reject和resolve是异步执行的回调。所以，resolve()会被放到回调队列中，在主函数执行完和setTimeout前调用
- await执行完后，会让出线程。async标记的函数会返回一个Promise对象

**Async**

- async function 声明将定义一个返回 AsyncFunction 对象的异步函数
- 当调用一个 async 函数时，会返回一个 Promise 对象
- 当这个 async 函数返回一个值时，Promise 的 resolve 方法会负责传递这个值
- 当 async 函数抛出异常时，Promise 的 reject 方法也会传递这个异常值

**await**

- await操作符用于等待一个Promise对象
- await表达式会暂停当前async
- function的执行，等待Promise处理完成，若Promise正常处理,其回调的resolve函数参数作为await表达式的值，继续执行async function
- await意味让出线程操作

```js
async function async1() {
    console.log('async1 start');
    await async2();
    console.log('async1 end');
}
async function async2() {
    console.log('async2');
}
console.log('script start');
setTimeout(function() {
    console.log('setTimeout');
}, 0)
async1();
new Promise(function(resolve) {
    console.log('promise1');
    resolve();
}).then(function() {
    console.log('promise2');
});
console.log('script end');
```

